## Exception 和 Error 有什么区别？

所有的异常的祖先都是Throwable，Exception是程序可以处理的异常，Error是程序无法处理的异常，没有办法捕获，直接停止程序的执行

## Checked Exception 和 Unchecked Exception 有什么区别？

受检查的异常和不受检查的异常，受检查的异常必须捕获或者抛出才能执行，不受检查的比如空指针异常、参数错误等都是可以执行的，然后执行后报出的异常

## Throwable 类常用方法有哪些？

- getMessage：异常的简要信息
- toString：详细信息
- getLocalizedMessage：重写自己定义，没有重写则返回和getMessage一样的信息
- printStackTrace：异常追踪信息

## finally 中的代码一定会执行吗？

finally之前虚拟机被终止、线程死亡和CPU被关闭时，finally不会被执行

## 如何使用try-with-resources代替try-catch-finally？

一些需要关闭的资源类推荐在try-with-resources中声明使用，这样不需要手动关闭，而try-catch-finally如果多个资源需要全部关闭，而且关闭之前还需要判断是否还未关闭，如果多线程已经关闭了还去关闭会报错

## 异常使用有哪些需要注意的地方？

- 不要抛出一个异常的静态变量，应该抛出一个new的异常类
- 抛出异常要具体(抛出具体子类不要上来就父类)，并且有含义
- 使用了日志，就不要抛出异常了

## 什么是泛型？有什么作用？

泛型可以增加代码的可读性和稳定性，通过设置泛型设置参数的类型指定传入的参数类型，可以不需要类型转换

## 泛型的使用方式有哪几种？

泛型类、泛型接口、泛型方法

其中要注意静态泛型方法，因为静态方法是类加载的时候加载，而类的泛型符号只是一个占位符，这个占位符的具体类型是实例化的时候传入的，所以静态方法没有办法使用这个泛型，也就是这个静态方法体中无法使用类泛型符号

但是可以使用自己这个方法的泛型符号，因为要调用这个方法的话，这时候可以传入泛型

## 项目中哪里用到了泛型？

- 自定义接口通用返回结果：通过泛型动态指定返回具体的数据类型
- 一些需要处理多种类型数据的类

## 何为反射？

反射是用于支持运行中获取一个类的方法和属性，以及调用这些方法和属性的工具

## 反射机制优缺点

优点是：让代码更加灵活，是很多框架的基础

缺点是：增加了安全问题，可以无视访问限制和安全检查，以及性能比直接访问要低

## 反射的应用场景

- Spring框架、MyBatis框架大量使用反射

- 可以用于创建对象
- 用于实现动态代理
- Java中的注解也使用到了反射

## 注解

可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。

注解可以在编译期通过扫描到注解，进行处理，也可以运行期通过反射对代码进行处理，比如Spring的各种注解都是运行期处理的

## 什么是序列化?什么是反序列化?

序列化就是将数据结构或者对象转为二进制流然后保存在文件或通过网络传入，注意类变量不会进行序列化，因为不属于对象

反序列化就是反过程，将二进制流转为数据结构或者对象

就跟Json的encode和decode一样

## Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

注意只能修饰变量，而且还不能是static变量，修饰之后，变量的赋值会被取消设置为默认值，也就是不传输这个值，但是属性还在

## 获取用键盘输入常用的两种方法

1. 通过Scanner

```java
Scanner input = new Scanner(System.in);
String s  = input.nextLine();
input.close();
```

2. 通过BufferedReader

```java
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();
```

## Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

总体的父类是：

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

## 既然有了字节流,为什么还要有字符流?

当我们操作字符的时候，是JVM将字节流转换过来的，这个过程非常耗时，而且不知道编码类型可能会出现乱码问题

所以I/O流干脆出了一个字符流，专门来对字符进行流处理

