## Java语言的特点？

- 面向对象：封装、继承、多态
- 跨平台：基于JVM虚拟机实现一次编写，随处运行，但是这个目前不算什么优点了，使用docker可以非常容易实现跨平台
- Java提供了多线程支持，C++ 2011年才添加了多线程支持，之前是基于操作系统的多线程来进行多线程设计，而Java提供了多线程支持
- 网络编程特别方便，Java语言就是为了简化网络编程而设计的
- 编译和解释并存，首先编译成字节码文件，然后通过JVM中的解释器解释执行(解释成机器指令)，同时因为解释执行速度较慢，JVM引入了JIT即时编译器，一个运行时编译器，来编译经常被调用的热点代码
- 强大的生态才是目前最大的优点

## JVM/JDK/JRE区别？

- JVM是运行Java字节码文件的虚拟机，是Java实现一次编写，随处运行的关键，不同操作系统上的JVM使用相同的字节码文件，都会得到相同的结果。
- JDK是Java开发工具包，包含了Javac编译.java文件为.class文件的编译器、Java类库以及JRE
- JRE是Java程序运行时环境，用于运行已经编译好的Java程序，除非一些特殊的，Web应用程序服务器运行JSP 时需要转换为 Java servlet时需要JDK来进行编译

## 字节码是什么？使用字节码的好处是什么？

JVM可以识别的代码就是字节码，只面向JVM虚拟机。

好处是：

- 因为经过了编译成字节码，一定程度上减轻了直接解释执行效率低问题
- 因为字节码运行在虚拟机上，可以使得Java代码一次编写，随处运行

## Oracle JDK vs OpenJDK

- OpenJDK是开源的，Oracle JDK并不是完全开源的，并且有一些版本不是商业免费的
- 两者在核心功能上基本一致，只是OpenJDK更新更快，这也导致OpenJDK没有Oracle JDK稳定，因为后者都是更新稳定的功能
- Oracle JDK性能更高，因为是Oracle官方团队维护的稳定版本

## Java 和 C++ 的区别?

- Java不提供指针访问内存，但拥有GC垃圾回收，也就不需要手动释放无用内存
- Java不支持多继承
- C++支持方法重载和符号重载

## 标识符和关键字

标识符就是名字，关键字是系统内部有作用的标识符，注意`true`、`false`、`null`不是关键字，而是字面量，只是不能定义为标识符

## continue、break 和 return 的区别是什么？

continue跳出当前这一轮循环，break跳出当前循环，return跳出当前方法

## 可变长参数

`(String... args)`可以匹配多个参数，要注意如果同时有重载方法，那么优先匹配重载方法，也就是说重载方法有两个参数，调用的时候传入了两个参数，那么肯定是匹配重载方法，而不是可变长方法

如果可变长参数方法还有其它固定参数，那么固定参数一定要放在可变长参数的前面

## 基本数据类型

一个字节是8位，可以根据数据类型占用几个字节，然后算出取值范围是多少

位数-1，因为有正负

| 基本数据类型 | 占用字节数 | 默认值  |
| ------------ | ---------- | ------- |
| byte         | 1          | 0       |
| short        | 2          | 0       |
| int          | 4          | 0       |
| long         | 8          | 0L      |
| float        | 4          | 0f      |
| double       | 8          | 0d      |
| char         | 2          | 'u0000' |
| boolean      | 1          | false   |

8个基本类型的包装类除了int是Integer，char是Character，其余都是名称首位大写

## 基本类型和包装类型的区别？

1. 基本类型有默认值，包装类型不赋值的话是null，因为是对象嘛
2. 基本类型不能用于泛型指定，泛型必须指定类，因为泛型运行时最终都要进行类型擦除为Object，而基本类型不是Object的子类
3. 存放位置不同，包装类型是对象类型肯定放在堆中，基本类型如果是方法中的局部变量类型那么放在虚拟机栈中，如果是成员变量也放在堆中，属于对象，但是如果使用了static静态修饰，是静态成员变量，那肯定随类存在方法区
4. 基本类型占用空间非常小，包装类型因为是对象类型占用空间更大

## 自动装箱和拆箱

将基本类型赋值给包装类型就会自动装箱，包装类型赋值给基本类型则会自动拆箱

```java
public static void main(String[] args) {
    // 自动装箱
    Integer i1 = 40;
    // class java.lang.Integer
    System.out.println(i1.getClass());

    // 自动拆箱
    int i2 = i1;
    // Error：基本类型不是类无法获取类型
    System.out.println(i2.getClass);
}
```

装箱/拆箱原理

```java
public class Test01 {
    public static void main(String[] args) {
        // 装箱原理
        Integer i1 = Integer.valueOf(40);
        // class java.lang.Integer
        System.out.println(i1.getClass());
        
        // 自动拆箱
        int i2 = i1.intValue();
        // Error：基本类型不是类无法获取类型
        System.out.println(i2.getClass);
    }
}
```

装箱使用的是`Integer.valueOf`

而拆箱使用的是`xxxValue`

## 包装类型的缓存机制

除了Float、Double两个浮点型没有使用缓存机制，其它包装类都有默认的缓存，也就是如果符合条件，那么创建一个包装类使用的是已经创建好的缓存对象

原理非常简单，就是Java默认创建了一定数量的包装类实例，只要是缓存范围内的就直接使用缓存好的实例

所以比较整型的包装类型大小，一定要使用`equals`方法，不能使用`==`虽然缓存范围内的内存地址是相同的，但是缓存范围外的，比如创建两个200的包装整型类，值相同，内存地址肯定不同(因为都是new的对象)