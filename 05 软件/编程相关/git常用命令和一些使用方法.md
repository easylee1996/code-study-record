---
创建时间: 2023-03-09T15:45
更新时间: 2023-11-23T11:47
---
## Git概述
Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。
分布式版本控制系统以前是集中式版本控制系统，常见软件如：SVN，主要区别如下：
1. 服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的），SVN断网没有历史记录；
2. 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）。

Git中的文件分为四个状态：
- 工作区：本地写代码的目录，此时文件未经Git负责监管。
- 暂存区：工作区文件通过 `git add`添加之后，保存到暂存区，此时文件变为已追踪状态，但未形成实际记录。
- 本地库：暂存区通过 `git commit` 提交之后，保存到本地库，形成版本，可以恢复。
- 远程库：本地库通过 `git push` 推送之后，提交到远程库，方便团队成员和外部人员使用。
## 常用命令
### 用户签名
设置用户签名是Git操作的第一步：
- 设置用户签名：`git config --global user.name 用户名`  
- 设置用户邮箱：`git config --global user.email 邮箱`

> 设置提交本地Git的签名，和远程推送无关，远程推送的用户签名是通过登陆形成的。`--global`表示设置全局签名，去除 `--global` 表示当前仓库签名，优先级大于全局签名。

### 本地库操作
- 当前目录创建本地库： `git init`
- 查看本地库状态：`git status`
- 撤销本地修改的文件到上次提交时状态：`git checkout -- filename`，所有修改都将失效。
- 撤销暂存区文件：`git reset <filename>`，之前的修改不会失效。
- 添加暂存区：`git add 文件名`，添加之后文件从未追踪状态变为已追踪。
- 提交本地库：`git commit -m '日志信息' 文件名`，不添加文件名，则提交所有暂存区文件。**每次提交必须记录清楚提交信息**
- 查看历史版本：
  - `git reflog`：简略查看
  - `git log`：详细查看
- 切换版本：`git reset --hard 版本号`
> 必须使用 `--hard` 才可以切换成功，注意：如果当前版本修改了文件还没有提交保存，那么切换回其它版本后，这些修改后的文件都丢失。
>
> Git切换版本的原理只是通过移动 `HEAD` 指针指向不同的版本号，并不是复制多份文件来切换。
### 分支操作
分支是通过复制多个副本，不同的功能在不同的副本上进行开发，开发完成后，合并到主分支中，这样不会影响到主分支正常运行的代码。
- 创建分支：`git branch 分支名`
- 查看分支：`git branch -v`
- 切换分支： `git checkout 分支名`，检出分支，切换分支的原理同样是切换`HEAD`的位置。
- 合并分支：`git merge 分支名`，把指定分支合并到当前分支上。
> 合并分支冲突：
> 如果指定版本中修改的文件，当前分支也修改过，那么就会发生冲突，解决方法如下：
> 1. 合并代码：`git merge 分支名`
> 2. 打开当前分支的冲突文件，并手动编辑想要最终保留的部分，然后保存这个文件
> 3. 添加到缓存区： `git add 冲突文件`
> 4. 提交代码：`git commit`，**这里不能带文件名**，因为是操作合并时的冲突文件，并不是具体的文件。

### 远程仓库
- 查看当前所有别名仓库：`git remote -v`
- 给远程仓库取别名：`git remote add 别名 远程地址`，非必须，也可以直接使用远程地址，只是不方便。
- 推送本地当前分支到远程仓库：`git push 别名 远程分支`
- 克隆远程仓库：`git clone 远程地址`
- 拉取远程仓库最新代码并合并到本地仓库：
  - `git fecth`：从远程拉取代码但并不合并进本地仓库；
  - `git merge`：合并拉取回来的代码；
  - `git pull 远程仓库别名 远程分支名`，这个命令是上面两个命令的组合。
- 远程的两个分支合并：均需要拉取到本地，然后合并之后提交推送，远程的分支也就合并了。

> 远程仓库注意事项：
> 1. 如果远程仓库的版本，比本地新，那么无法推送数据，所以**推送之前务必拉取代码。**
> 2. 拉取代码会直接和本地进行合并，如果存在冲突是无法拉取的，正确步骤是：
>    1. 将本地修改代码提交到本地仓库；**有时候不提交不冲突也不会报错，但是不推荐**
>    2. 拉取远程代码；
>    3. 修改冲突文件；
>    4. 提交并推送修改好的冲突文件。
> 3. 使用远程仓库首先需要邀请，加入后才可以进行代码拉取和推送。

- 开源项目：开源项目和团队项目略有不同，具体如下：
  - 首先需要 `Fork`代码，也就是复制一份远程的副本到远程，一般到远程`Github`上；
  - 然后拉取代码、修改代码、推送代码；
  - 修改完成后，添加 `Pull Request(PR)`请求让开源项目管理员拉取，并写上注释；
  - 管理员 `Merge pull request `合并代码。

### 其它常用命令
#### 1.忽略不想提交的文件
比如包含账号密码的配置文件，需要先提交一份默认的，然后后面不再提交。
修改为默认账号密码之后，提交这个文件到远程仓库，然后将这个文件加入：. gitignore 文件中，不要先加入，先加入直接首次就不提交了，提交之后执行下面的命令，来取消 git 对这个文件的监控：
```shell
git update-index —assume-unchanged 文件名
```
取消监控之后，再次修改该文件则不再监控。
需要注意的是，如果不执行上面的命令，只是加入. gitignore 文件中，是没有效果的，因为之前提交到仓库中，已经被监控了。
#### 2.
## 相关问题处理
### 远程库登陆相关
- `Https`方式：克隆之后，连接需要登陆帐号密码，不方便，但是如果是使用的SourceTree或者vscode等软件，则不需要，因为这些软件登陆后会保存登陆信息。
- `SSH`免密登录：

  - 首先创建本地电脑的 SSH 公钥和私钥：
  ```shell
  # 创建公钥私钥
  ssh-keygen -t rsa -C xxx@qq.com
  # 获取公钥并复制
  cat id_rsa.pub
  # 保存位置：/Users/easylee/.ssh/id_rsa
  ```
  - 登陆 `Github`：点击用户头像→Settings→SSH and GPG keys，添加刚才复制的公钥；
  - 之后上传代码，可以直接推送了。
> SSH免密登录原理：
> 1. 客户端生成公钥和私钥两个文件；
> 2. 公钥传递给需要验证客户端身份的服务端，所有服务端都可以；
> 3. 请求时，客户端发送私钥信息到服务端，进行认证；
> 4. 认证成功，则登陆成功。
> 使用SSH登陆的方式安全性比较，但是一定要注意私钥一定不能泄漏，拿到私钥就可以进行随意登陆。

### 代理问题说明
多数情况下，连接Github是需要进行代理的，下面来看一下代理问题的配置。Git远程库有两种连接方式，`https`和 `ssh`，两种方式需要不同的代理方式：
**Https代理**
- iterm2：使用命令行连接，代理需要配置命令，可以使用`proxifier`等软件进行配置，直接输入命令比较麻烦。
- SourceTree：代理需要进行如下配置，注意是针对项目仓库的，而不是全局
  - 打开项目后-右上角设置-远程仓库-编辑配置文件
  - 添加如下代理信息：
    ```json
    [http]
    	sslVerify = false
    	proxy=127.0.0.1:7890
    ```
    其中的端口来源于代理软件启动之后，将本地网页代理和安全网页代理配置成的ip，在网络连接，代理处即可查看
    ![image-20230315104500129](image-20230315104500129.png)
- Github Desktop：不需要配置，默认就会使用上面的网页代理和安全网页代理的端口。
**ssh代理**
`ssh`代理方式完全不同，可以搜索参考proxifier软件的相关配置，所以推荐使用 `https`连接github的项目即可。
> 注意：代理软件使用全局代理对sourcetree和iterm2这些软件是不起作用的，这个设置只是对使用了网页代理和安全网页代理的软件起作用，前面这两个软件默认是不走系统的网页代理的，所以需要进行配置。

### Https证书问题
默认应该开启证书验证，以保证安全，如果是本地自建的仓库没有证书，必要时可以关闭
```shell
git config --global http.sslVerify false
```
### 403问题
一般使用SourceTree进行推送，出现这个问题，原因是[2021.8.13起，Github要求使用基于令牌的身份验证](https://zhuanlan.zhihu.com/p/401978754)，也就是需要设置Token，而且是有期限的，比较麻烦。
使用官方的**Github Desktop**，则没有这个问题，推荐使用这个软件进行Github项目的传输，不用设置token也不用再多配置一步代理(前提是已经开了代理)。
## git commit 提交信息规范
### 标题
提交标题应该简洁明了、动词开头、描述具体内容等。标题通常包含：类型、范围、描述三个部分，三个部分的使用方式如下：`fix(build): enforce LF line ending in built files`，下面具体看看三个部分：
#### 1. 类型(type)
下面几个类型是对功能代码进行修改：
- `feat`：新增功能、特性、配置、选项、文档、测试用例等，新增内容均使用 `feat`，通常还应该注意，如果新功能比较大，应该拆分成小功能块，一块一块的提交，而不是整体提交。
- `refactor`：用于代码重构，旨在改善代码的结构、设计，不影响代码的功能，提升可读性和维护性。
- `perf`：用于代码性能优化的更改。例如：优化算法、提高代码的执行效率等。
- `fix`：修复bug和缺陷。

下面的几个类型，不会对功能代码产生影响，构建过程修改用 `build`，持续集成中的修改用 `ci`，而`chore`除了更新某个依赖库、添加构建脚本，还可以干 `style` 的活：
- `chore`：翻译含义乏味的工作，比如变量名单词写错、多些一个符号、注释少写一段话、大意写错一些东西，总之这类的小修改都可以使用 `chore` 类型。
- `ci`：用于持续集成系统的更改。例如：添加 Travis CI、修改 Jenkins 配置等。
- `build`：用于构建过程中的更改。例如：更新构建工具、改变构建配置等。
- `style`：用于对代码样式或者格式的更改，不影响代码的功能，但是不包括修改CSS，这是feat。例如：调整缩进、改变变量命名等。通常不使用style，在vue.js这些内容通常使用chore类型。
- `docs`：用于对文档的更改。例如：更新 README.md 文件、添加 API 文档等。
- `test`：用于修改测试用例的更改。例如：添加单元测试、修改端到端测试等。

除此之外，还有一些其它的类型：
- `revert`：用于回滚先前的提交。例如：撤销上一个提交、回到某个早期的版本等。
- `WIP`：表示提交仍在进行中，尚未完成，不常用，不建议将未完成的代码进行提交，除非需要将代码提交给另外的团队成员进行查看。
- `release`：表示发布一个新版本，包括版本号。

#### 2. 范围(scope)
范围用于提交本次修改影响的代码范围，非必填项，通常可以不写。
#### 3. 描述(describe)
描述内容必须符合下面的规则：
- 简介明了
- 动词短语：`add a new feature`、`fix a bug`
- 详细描述：如果改动了很多重要内容或者存在潜在问题，应该在描述中进行一些简要描述。
- 包含引用：如果是根据其他 issue、pr、bug等信息进行修改，则应该写上这些内容的链接。

### 正文
正文内容通常是可选的，如果本次提交内容较为复杂，则应该进行详细的解释，可以使用 `markdown`进行详细排版解释。
但是一般大改动会涉及到版本变更，而版本变更不应该在一个commit信息中书写，而是应该写入到专门 `CHANGELOG.md`文档中进行详细的记录。
### 脚注
脚注信息通常用于提供一些额外的信息，比如参考文献，关联的issue、关闭的issue，关联的bug之类的。
举例说明：
```shell
# 关闭issue，提交后会自动关闭对应issue
feat: add new feature
...
Close #123

# 关联issue
fix: fix issue with component
...
Related to #456

# 参考文档
docs: update documentation
...
See https://vuejs.org/ for more information
```
## git commit提交自动化检测工具
自动化检测工具可以生成类型之类的选项以供选择，同时可以检测正文标题是否符合规范。
目前暂不使用，手动写即可，但是可以了解一下具体的用法。
### commitlint
commitlint 是一个 Git 提交信息规范校验工具，它可以帮助开发者自动化检测提交信息是否符合预设的规范。在项目中集成 commitlint 可以帮助开发团队保持提交信息的一致性和规范性，提高代码的可维护性和可读性。
commitlint支持多种规范，常见的有Angular(vue也是使用这种规范)、Conventional Commits，两种规范基本一致，以Conventional Commits规范为例：
```php
<type>[optional scope]: <description>
[optional body]
[optional footer]
```
下面来配置 commitlint，首先安装一些必要的依赖，config-conventional是配置文件：
```shell
npm install --save-dev @commitlint/cli @commitlint/config-conventional
```
然后在项目中创建一个配置文件 `commitlint.config.js`：
```js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    // 在此处自定义规则
  }
};
```
自定义规则可以按照这样的格式：
- type-enum：指定 commit 类型的枚举值。比如 feat、fix、docs、style 等。
- subject-case：指定提交信息的主题部分的大小写格式。比如使用小写、大写、首字母大写等。
- subject-max-length：指定提交信息的主题部分的最大长度。
- body-max-line-length：指定提交信息的正文部分每行的最大长度。
- footer-max-line-length：指定提交信息的注脚部分每行的最大长度。

举例说明：
```json
module.exports = {
  extends: ['@commitlint/config-conventional'],
  // level：0关闭规则 1警告 2表示报错并阻止提交，下面三个规则中的2表示错误时阻止提交
  rules: {
    'type-enum': [
      2,
      'always',	// 始终应用
      ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore', 'revert'],
    ],
    'subject-case': [2, 'always', 'sentence-case'],
    'body-max-line-length': [2, 'always', 72],
  },
};
```
这样`commitlint`就安装配置完成了，但是这样只是定义好了规范，但是我们使用Git工具提交时并不会使用这些规范，接下来来看一下Git钩子管理工具`husky`
### husky
husky是一个Git钩子管理工具，会在执行各种Git命令时，自动调用对应的钩子函数，执行对应的逻辑，下面来安装配置一下。首先安装husky：
```shell
npm install husky --save-dev
```
然后在 `package.json`中添加配置：
```json
{
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS" // 调用commitlint并传递HUSKY_GIT_PARAMS参数
    }
  }
}
```
配置完成后，执行 `git add .`、`git commit`就会自动调用上面的钩子函数，然后钩子函数自动调用`commitlint`来检查git commit提交规范。
