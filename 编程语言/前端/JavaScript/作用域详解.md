通过一套规则来存储变量，以便后期方便的使用这些变量，需要设置特定的规则，这种规则通常被称为作用域。

## 编译原理

JavaScript实际上是一门编译语言，虽然经常把它称为"动态"或"解释执行"语言，编译发生在浏览器渲染完成之前的瞬间。

### 编译过程

- 分词/词法分析：分词表示将代码分解成一个一个的具体单元，如果某些单元比如var关键字会进行词法分析赋予其语义。

- 解析/语法分析：将分词单元转换为一颗树形结构结合在一起，成为抽象语法树AST。如 `var a = 6;` 分为 `var`、 `a`  、`=` 、`6`、 `;`。

- 代码生成：根据AST编译转化为具体的可执行的二进制代码，同时进行内存分配等操作。

除此之外JavaScript引擎还会进行性能优化、冗余元素优化等操作。

### 引擎、编译器和作用域关系

在JavaScript中，引擎负责整个JavaScript程序的编译和执行，编译器负责词法分析、语法分析和代码生成，作用域负责对变量根据规则进行嵌套查询其可用性。

**引擎是负责整体的，调用编译器进行词法分析、语法分析，编译生成可执行代码，然后引擎来执行这些代码，其中使用到变量时，由作用域来查询变量是否可用。**

在编译时，遇到赋值语句是不会进行赋值的，只会进行声明，等到引擎执行到这里的时候，再进行赋值。

这也解释了**变量提升问题**，一个变量先使用，后面再声明赋值，这个变量的值是`undefined`，而非`ReferenceErr`，原因是所有声明语句通过编译器先执行，且均为 `undefined` ，然后引擎执行时再进行赋值。

## 词法作用域

前面简单研究了一下引擎和编译器，引出了作用域，下面具体看一看JavaScript中的作用域。

JavaScript 采用的是词法作用域(也就是静态作用域)，**函数的作用域在函数定义的时候就决定好了**，所以JavaScript是静态作用域，与指向对应的是动态作用域。

举例说明静态作用域：

```javascript
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();  // 1，在foo定义的时候，value为1
```

举例说明动态作用域，比如**bash**语言就是采用的动态作用域：

```bash
value=1
function foo () {
    echo $value;
}
function bar () {
    local value=2;
    foo;
}
bar	// 2-在执行到foo才去寻找$value的值
```

可以看出，最主要的区别还是在于，静态作用域在函数定义的时候里面的变量是什么值，执行的时候就是什么值，而动态作用域则在执行时判断。

## 作用域查询方式

查询一个变量需要考虑作用域问题，通常有以下三种形式：

- 嵌套查询：从内往外查询变量，从内部作用域往外部作用域查询变量，如果函数内的变量不仅可以使用函数内声明的变量，还可以使用函数外部全局的变量。
- LHS左查询：引擎运行时查找到赋值=号左边的变量时，**只会查找其对应地址**，然后为其赋值，在非严格模式下，如果此变量此前未声明则会自动声明一个全局变量，严格模式下，则会报引用错误`ReferenceError`。
- RHS右查询：赋值=号右边的变量，**执行到此处时会直接查找其对应的具体值**，如果没有则会报引用错误`ReferenceError`，如果有但是使用方式不对则报`TypeError`类型错误，比如变量当函数fn()来使用。

以`var a = 10`、`console.log(a)`、`fn()`为例，第一个a为左查询，后面两个为右查询。

### 欺骗词法

虽然JavaScript是词法作用域，但是仍然可以通过一些方式来欺骗词法作用域，修改其作用域。

- eval：eval一段字符串，这个字符串中的变量的作用域会在执行eval的位置，从而给函数作用域添加一些变量，改变原本作用域内的变量。类似的有setTimeOut、setInterval、new Function函数，都可以执行一段字符串，给目标作用域添加变量，但都不推荐使用，会降低性能。

- with：with的第一个作用是可以将一个对象的多个属性提取出来使用，而不用重复的输入"对象.属性"的形式获取属性。with的实际作用是通过with操作符创建一个基于对象的作用域，但这个作用域中的属性变量不会被限制在这个作用域中，而是被添加到with的所在的函数作用域中。

如果with生成的对象作用域中的变量，在外层以及全局中都没有找到这个变量，那么费严格模式下，肯定会提升到全局变量中，创建一个全局变量。

**不推荐使用eval和with，所有欺骗词法的方法都不推荐使用**，首先是浪费性能，其次在严格模式下，eval和with都会收到影响，with更是直接禁止了，可能会导致很多错误。

性能降低的原因是，在编译阶段词法分析时，遇到eval和with无法明确里面具体会收到什么代码，无法判断这些代码会如何对作用域进行修改，也无法知道传递给with用来创建新词法的对象作用域的内容具体是什么，所以无法对这些代码进行优化，导致运行速度变得更慢。

## 函数作用域和块作用域

函数作用域的含义是指，属于这个函数内部(包含里面的嵌套函数)的变量，整个函数内部均可以使用这些变量，而这个函数外部无法访问其中的变量。

基于这个，要学会的一个原则是**最小特权原则**，也就是尽可能将一些变量和函数隐藏起来，而不是放在全局作用域中，避免一些冲突。

比如