## 对象创建流程

一个对象创建的整个流程如下：

1. new一个对象，首先检查常量池中是否有这个类的符号引用，是否加载、解析和初始化过，如果没有执行对应的类加载机制加载类
2. 分配内存：类通过类加载器加载之后，就要给实例对象分配内存了

分配内存主要有两种方式：一种是分配规整的内存，一种是不规整由虚拟机维护记录的散乱的内存，堆内存是否规整，取决于选用的GC回收期的算法，选用标记-清除算法，那就不是规整的，选用标记-整理或者复制算法，就是规整的

内存分配并发问题：为了给新对象分配内存时线程安全，采用两种方式：

一种是CAS+失败重试，也就是乐观锁，每次新建不加锁，失败了不断重试，直到成功

另外一种是TLAB，即每个线程先在新生代Eden区创建一块TLAB内存，每个线程有自己的内存，新对象首先在这里创建，如果新对象需要的内存大于TLAB或者TLAB满了，才使用上面的CAS+失败尝试进行内存分配，也就是不区分线程了，所有的线程都去堆中创建了，但是首先要每个线程TLAB满了之后

1. 初始化零值：内存分配好了，给分配到的内存空间初始化为零值，但是对象头除外
2. 设置对象头：也就是对象的相关信息的设置，包括元数据信息、哈希吗、GC年龄等
3. 执行初始化：调用`<init>`进行初始化，比方说字段设置初始值，都在这里进行设置，执行之后，一个对象才算创建

## 对象的内存布局

一个对象在内存中主要包括三块：对象头、实例数据和对齐填充

1. 对象头：一部分是对象自身的运行时数据，包括哈希码、GC年龄、锁状态，另一部分是类型指针，指向对应的类元数据，确定是哪个类的实例
2. 实例数据：就是这个对象真正存储的有效信息
3. 对齐填充：因为虚拟机要求对象起始地址是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍，其中对象头是8字节的1倍或者两倍，所以实例数据没有达到8的整数倍时，要进行对齐填充，仅仅起到占位作用

## 对象的访问定位

栈中引用变量要找到堆中的具体对象实例主要有两种方式：

1. 句柄：在堆中创建一个句柄池内存，然后通过这个句柄再找到堆中的实例数据和方法区中的类数据，这样做的好处是，如果对象被移动的话，引用变量不需要改变，只需要改变堆中句柄池的指向
2. 直接指针：占用引用变量直接存储堆中的实例数据的地址，同时这个实例对象中自己包含了方法区类数据的地址，这样好处是速度快，直接找到实例对象