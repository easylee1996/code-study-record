---
创建时间: 2023-03-14T18:15
更新时间: 2023-11-23T11:47
---
## 面向对象和面向过程的区别？

主要在于解决问题的方法不同：面向过程直接通过一个一个的方法来解决问题，面向对象先抽象出对象，然后通过对象来执行方法解决问题

同时在性能方面：一般来讲面向过程的性能更高，除了面向过程不需要实例化对象有开销，还在于面向过程语言一般都是编译型语言，直接变成机器指令来执行，性能更高

## 成员变量与局部变量的区别

成员变量属于类，静态随类存在方法区，非静态随对象存在堆中，而局部变量属于方法存在栈中和代码块

另外局部变量如果不赋值，没有初始值，未赋值时无法使用

## 创建一个对象用什么运算符?对象实体与对象引用有何不同?

new关键字创建，对象实例存放在堆中，对象引用随方法存放在栈中，可以修改指向

## 对象的相等和引用相等的区别 

对象相等指的是对象里面的具体值相等使用`equals`判断，而引用相等指的是内存地址相等使用`==`判断，引用不相等但是对象里面的值很可能是相等的，所以要使用`equals`判断

## 类的构造方法的作用是什么?

主要是对对象实例进行初始化

## 如果一个类没有声明构造方法，该程序能正确执行吗?

可以正确执行，默认有无参构造函数，但是我们重载了有参的构造，一定要把无参构造写一遍，无否就没有无参构造了，调用的时候一旦`new Student()`，调用的是无参就出错了

## 构造方法有哪些特点？是否可被 override?

名字和类名字相同，没有返回值，生成类的时候自动调用

无法被重写，但是可以重载

## 面向对象三大特征

### 封装

就是把一个对象的属性信息隐藏在内部，不允许外部对象直接访问，但是可以提供一些接口来操作可以被操作的属性

### 继承

就是一个类复用另一个类，更快速的创建一个类

子类拥有父类所有的属性和方法，但是私有的无法调用，可以扩展父类，可以重写，但是最好不重写，因为重写不符合里氏替换原则

### 多态

就是一个对象具有多种形态，常用于父类引用指向子类的实例，或者接口引用指向实例

对象和引用指向必须是父类、子类或者接口和实例，在运行时才能确定方法调用调用的是哪个子类哪个实例的方法，子类重写了就是调用子类的，没有的就是调用父类的，要注意如果父类根本没有这个方法，那么就不能调用

## 接口和抽象类有什么共同点和区别？

共同点：都不能被实例化，都可以有抽象方法，都可以有默认实现的方法

不同点：

1. 接口强调的是行为约束，一个类实现了接口就表示要有这些行为，拥有了这些行为，而抽象类强调的是所属关系，强调复用，一个类继承了抽象类，总体来讲，接口更多用于给一个类增加一些方法，而抽象类更多用于表示一个类是这个抽象类型模板的子类
2. 可以实现多个接口，但是只能继承一个类
3. 成员变量不同：接口中只能定义静态常量且必须设置默认值，可以省略static final简写，而抽象类中可以重新定义重新赋值

## 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

![img](shallow&deep-copy.8d5a2e45.png)

- 浅拷贝：只会拷贝一些基本类型的字段，引用类型是直接复用被拷贝对象的地址，实现方式首先被拷贝对象要重写clone方法，并实现Cloneable接口
- 深拷贝：完整拷贝整个对象，包括成员引用类型都是拷贝一个新的，可以使用引用类型也实现拷贝递归实现，或者使用序列化实现
- 引用拷贝：只是拷贝这个地址，新老引用变量都是指向一个对象

## Object 类的常见方法有哪些？

Object主要包含很多本地方法，以及多线程、回收的方法

主要方法：

- public final native Class<?> getClass()：获取运行时Class对象，也就是JVM类加载时产生的类信息的对象
- hashCode：返回hashCode
- equals：默认的是比较内存地址是否相等，使用一般都需要重写
- clone()：拷贝方法，要使用拷贝都需要重写这个方法，因为是一个protected受保护的方法

## == 和 equals() 的区别

首先要明确基本类型和引用类型是不同的

- 基本类型使用`==`比较两个基本类型值是否相同，而且不能使用`equals`进行比较，因为equals是Object的方法，基本类型不是对象，不是Object的子类，没法使用方法
- 引用类型使用`==`比较的是两个对象的内存地址，`equals`如果没有重写也是按照Object比较内存地址，一般会进行重写，比较具体值是否相等

## hashCode() 有什么用？

主要用于获取哈希码，然后确定对象在哈希表中的索引位置，然后快速的找到对象的位置

hashCode和equals配合使用：

1. hashCode()确定索引位置，需要配合使用equals()

2. 以HashSet为例，加入一个对象进入HashSet，首先判断计算哈希码，然后和已经存在的哈希码对比，如果没有相同的则直接加入，如果有哈希码相同，再对比equals是否值相同，相同则不加入完全重复

3. 如果不相同，则代表哈希碰撞，哈希码相同，但是具体值不同

有了HashCode()方法之后，效率更高，如果只有equals判断是否相同，效率非常低

总结：

1. 哈希码不同，两个对象肯定不同
2. 哈希码相同，两个对象有可能不同，哈希碰撞，equals也相等才判断两个对象相同

## 哈希碰撞的解决方案

只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。

jdk8前使用链表解决哈希碰撞。

jdk8之后使用链表+红黑树解决哈希碰撞。

## String、StringBuffer、StringBuilder 的区别？

- String是不可变的，适合操作少量不需要变更的数据
- StringBuffer是变的，适合操作大量线程安全的数据
- StringBuilder是可变的，适合操作大量单线程的数据

## String为什么不可变

不可变原因如下：

1. String底层保存字符串的字符数组被 `final` 修饰且为私有的，并且 `String` 类没有提供/暴露修改这个字符串的方法
2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变

而我们每次修改String变量的值，只是新创建了一个字符串而已，然后底层保存字符串的字符数组也是新的，要注意这个字符数组是final修饰，它指向的具体堆中的数组，这个指向地址是不能变的，但是堆中的数组是可以修改的