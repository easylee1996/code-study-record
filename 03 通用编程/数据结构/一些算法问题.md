## 给你N个数，查询是否存在

问题描述：给你N个(1-10000内)数，查询某个数是否是这个N个数中的一个，不能使用HashMap、HashSet

解决方案：

1. 顺组顺序查找：很慢，O(n)
2. 数组二分查找：需要排序，然后二分查找
3. 简单哈希查找：创建10000容量的数组，默认值设置0，插入这N个数时，每个数作为索引，然后值设置为1，查找的时候直接找到数组的这个数索引，看是否为1，则可知道是否存在，O(1)，这就是一个简单的hash查找，根据索引，找到具体的值，、
4. 改造哈希查找：如果这个数不是10000，而是1000000，那么创建一个这么大容量的数组，很明显不可能，只能缩小索引的范围
   1. 如何缩小索引范围，这就涉及到设计hash算法，假设将N个数的每个数都取模%10，然后当做索引，那么就只需要数组容量10了，当然这个取模值可以变化，这个取模操作就是一个简单的hash算法
   2. 现在出现一个新问题，如果所有数都取模10，就会出现多个数都在一个位置，这就是hash碰撞，下面就要解决hash碰撞问题，其实在hash算法中，一定会出现hash碰撞问题，因为无论你取模多少或者容量多少，只要新加的数超过了这个容量那么就会重复占用一个位置，导致hash碰撞(鸽巢原理)
   3. 一种解决方法是：`线性寻址`，首先根据hash算法找到索引位置，插入元素，第二个数如果还是这个索引，就从当前位置挨个找到后面的空位置，然后插入，使用这样的方式解决碰撞，查找的时候还是找到索引，比对索引位置是否和查找数一样，不一样挨个往后查找比对，直到找到下一个空位置都没找到的话，就说明不存在，线性寻址还有一个问题是，如果要删除一个元素，必须把这个位置标记为Delete，然后查找的时候找到这个位置不论是索引还是delete标记，都往后搜索
   4. 另外一种是：`数组+链表`，碰撞后，后面接一个链表，如果链表过长就将链表设置为红黑树(HashMap)
   5. 为什么不用数组+数组？因为hash碰撞后面使用另外一个数组来接所有碰撞的数据，有扩容问题，扩容效率很低