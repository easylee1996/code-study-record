## 运行时数据区域

内存区域主要包括：线程共享的方法区、堆，和线程私有的虚拟机栈、本地方法栈、程序计数器，在JDK1.7及以后，方法区的实现从永久代变为了元空间，使用系统直接内存，方法区中的字符串常量池、静态变量和运行时常量池放入了堆中

## 程序计数器

字节码解释器依次执行一条一条的指令，中间如果有分支、循环、线程恢复等操作，需要改变程序计数器的值来找到下一条应该执行的字节码指令，也就是说程序计数器就是一个行号指示器，指示字节码解释器解释哪一行代码

每个线程都有一个独立的程序计数器，随线程结束而死亡，只占很小的内存空间，所以是唯一一个不出出现OOM内存溢出的区域

## Java虚拟机栈

Java中每一个方法(除了本地方法)都会进入栈，每一个方法是一个栈帧，一个栈帧包括以下4个部分：

1. 局部变量表：编译器可知的基本类型局部变量，以及对象引用指向符号引用，但是要注意不是所有的基本类型数据都放在栈中，也可以是在堆中，比如创建一个数组对象，里面存放1,2，这里的1,2就随着数组对象存放在堆中
2. 操作数栈：方法执行过程中一些中间计算结果和产生的临时变量，比方说循环
3. 动态链接：编译成字节码文件之后，所有的方法和变量都作为符号引用保存在Class文件的常量池中，动态链接主要作用是将符号引用转换为调用方法的直接引用。也就是连接过程的解析阶段进行的。
4. 方法返回地址

注意点：

1. 除了`return`可以弹出这个栈帧，还有抛出异常也会
2. 栈可能存在的两种错误：一种是当栈的深度达到虚拟机栈的最大深度会报StackOverFlowError栈溢出，第二种是如果虚拟机栈可以动态扩展，但还是无法申请到内存空间，则会报OutOfMemoryError内存溢出

## 本地方法栈

和Java虚拟机栈其它方面基本类似，只是用于保存`native`本地方法。

## 堆

堆是线程共享的，是最大的一个内存区域，主要用于存放对象实例、数组

但是从JDK1.7开始，默认开启逃逸分析，如果对象没有逃逸出去，也就是方法中声明的对象引用，没有return这个对象或者没有被外部使用，只是当前这个方法使用，那么就直接随这个方法在栈中分配内存，这样做这个对象实例随栈弹出，更加方便，不需要垃圾回收了

### 堆内存分配区域

主要分为新生代、老生代、永久代，对象首先会在新生代分配，存满之后进行垃圾回收，如果还存在，那么转入新生代的幸存区S0或者S1，年龄+1，然后每执行一次垃圾回收，年龄都会+1，年龄达到15(通过XX:MaxTenuringThreshold参数设置，15是因为标记年龄的这个字段只分配到4位，也就是15)，则转入老年代，如果某个年龄的对象数量操作了幸存区的一半的话，取这个年龄和设置的参数中更小的一个为进入老年代的阈值，当然阈值变更之后，比操作一半数量的年龄的年龄大的肯定直接进入老年代了

注意点：

1. S0和S1的说明：幸存区S0满了之后，调用垃圾回收，然后幸存的保存到S1，S1满了，执行垃圾回收，就转到0
2. 1.7和1.8之后主要区别就是永久代变为了元空间使用直接内存
3. 永久代是一个概念，永久代既属于堆，也属于方法区，方法区在物理上存在于堆中的永久代中，逻辑上方法区和堆是独立的
4. 堆常见错误：OutOfMemoryError主要分为几种OOM错误，一种是垃圾回收时间长但是回收的堆空间很少报GC Overhead Limit Exceeded，堆内存不足无法创建新对象，报Java heap space，当然前缀都是OOM错误

## 方法区

方法区是一个规范概念，永久代和元空间都是这个概念的实现，1.7以前方法区是存在于永久代也就是堆中，以后是存在元空间也就是直接内存中

主要用于保存类相关信息：类信息、字段信息、方法信息、常量、静态变量、JIT及时编译器编译的代码缓存

元空间替换永久代的原因：

1. 永久代受虚拟机本身内存限制，元空间使用直接内存，更不容易溢出
2. 1.8是合并其它的虚拟机，其它没有永久代的概念，所以合并后直接去掉了

## 常量池详解

常量指的是一个对象是常量，比如字面值"abc"，首先是一个对象，然后是一个常量，不是说就不是对象了

常量池分为：Class常量池、运行时常量池、字符串常量池

- Class常量池：编译成字节码文件之后，字节码除了存放类的各种信息，还有一个常量池，存放各种字面量和符号引用，字面量包括基本类型值、文本字符串和`final`修饰的常量，在编译期有效
- 运行时常量池：就是将字节码文件加载到内存中，常量池变为运行时常量池，会把符号引用转换为直接引用，1.7及以前保存在永久代实现的方法区中，之后保存在元空间实现的方法区中，在运行期有效
- 字符串常量池：JVM为了提高性能，避免重复字符串反复创建，专门开辟一段内存，相当于字符串的缓存区，再次创建重复的字符串时，直接使用之前字符串常量池中的地址，1.7以前存放在方法区中，1.7及以后存放在堆中，和静态变量一起，可以更高效的回收

```java
    public static void main(String[] args) {
        
        String s1 = "hello";	// 创建了一个字面量常量，存放在字符串常量池
        
        // 这里会创建两个对象，一个是hello字面量常量，但是以为已经存在所以不创建
        // 然后创建new String对象，存放在堆中，这个对象指向字面量地址，但是s2是指向new String堆中的地址的
        String s2 = new String("hello");	
        
        String s3 = "hello";	// 不新创建，直接指向堆中的字符串常量池
        
        System.out.println(s1 == s2);   // false
        System.out.println(s1 == s3);   // true
    }
```

运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。